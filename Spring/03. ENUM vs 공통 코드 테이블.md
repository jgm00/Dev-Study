# ENUM vs 공통 코드 테이블 : 왜 참조 테이블이 더 나은 선택인가

## 목차
- [1. ENUM의 개요](#1-enum의-개요)  
- [2. ENUM의 주요 단점 8가지](#2-enum의-주요-단점-8가지)
    - [2-1. 정규화 위반](#2-1-정규화-위반)
    - [2-2. 값 변경이 매우 비효율적](#2-2-값-변경이-매우-비효율적)
    - [2-3. 연관 데이터 저장 불가](#2-3-연관-데이터-저장-불가)
    - [2-4. 가능한 값 목록을 직접 조회할 수 없음](#2-4-가능한-값-목록을-직접-조회할-수-없음)
    - [2-5. 성능 최적화 효과 미비](#2-5-성능-최적화-효과-미비)
    - [2-6. 재사용 불가](#2-6-재사용-불가)
    - [2-7. 입력 오류 발생 가능성](#2-7-입력-오류-발생-가능성)
    - [2-8. 비표준 SQL 문법](#2-8-비표준-sql-문법)
- [3. ENUM이 적합한 상황](#3-enum이-적합한-상황)


## 1. ENUM의 개요

- `ENUM` 타입 : 열거형 데이터를 표현할 수 있는 데이터 타입
- 컬럼에 저장될 수 있는 값을 미리 정의하여 해당 값 외에는 저장되지 않도록 제한
- 예시 : ```continent ENUM('Asia', 'Europe', 'Africa', 'Oceania', 'Americas')```
- 문제점 : 데이터 베이스의 정규화 원칙을 위반하고, 유지보수 및 확장성 측면에서 문제 야기
- 대안 : 별도의 공통 코드 테이블(참조 테이블)로 분리하고, 외래키(FK)로 연결

---

## 2. ENUM의 주요 단점 8가지

### 2-1. 정규화 위반

> ENUM은 가능한 값을 테이블이 아닌 스키마 정의에 하드코딩

- 예: continent ENUM('Asia', 'Europe', 'Africa')
- 이 값들은 사실 continent_code라는 별도의 테이블에 관리되어야 할 정형 데이터임

- RDBMS의 기본 원칙인 정규화(Normalization)에 위배
  - 데이터가 테이블에 존재하지 않고 스키마 정의의 일부분으로만 존재

- 정규화를 지키지 않으면 다음과 같은 문제가 발생:
  - 다른 테이블과의 참조 불가능
  - 값 변경 시 다수의 테이블과 연계되지 않음

### 2-2. 값 변경이 매우 비효율적

> ENUM은 값 변경 시 ALTER TABLE이 필요하며, 이는 전체 테이블을 스캔할 수 있음

- 예: ENUM('red', 'blue', 'black') → ENUM('red', 'blue', 'white')
  - black은 ENUM 정의에서 사라짐 → 기존 row 전수 스캔 후 재구성 필요

- 성능 문제:
  - 수백만 row의 테이블에서 값 하나 바꾸려면 테이블 전체 재구성

- 반면, 공통 코드 테이블은 UPDATE code_table SET name='white' WHERE code='B3'만으로 변경 가능

### 2-3. 연관 데이터 저장 불가

> ENUM 값은 그 자체로는 추가 속성을 가질 수 없음

- 예: 대륙별 면적, 코드 활성화 여부, 설명 등을 추가해야 할 경우
  - continent ENUM('Asia', 'Europe')는 단지 텍스트 나열

- 참조 테이블은 다음처럼 확장 가능:
  - ```continent(code, name, area_km2, is_active)```
- 즉, ENUM은 확장성과 메타데이터 관리 측면에서 취약

### 2-4. 가능한 값 목록을 직접 조회할 수 없음

> ENUM은 SELECT *로 가능한 값을 조회할 수 없음

- 예: 프론트엔드 드롭다운에 쓸 목록을 불러오려면?
  - 참조 테이블: SELECT * FROM color ORDER BY display_order
  - ENUM: INFORMATION_SCHEMA.COLUMNS 또는 SHOW COLUMNS로 파싱 필요 (복잡, 비표준)
- ENUM 값 목록은 코드에서 직접 관리하거나 파싱해야 함

### 2-5. 성능 최적화 효과 미비

> ENUM은 '성능'을 이유로 옹호되지만, 실제로는 큰 효과가 없음

- MySQL은 ENUM을 내부적으로 정수로 매핑하지만:
  - 대부분의 실무 쿼리는 JOIN, WHERE 등에서 발생
  - 정규화된 테이블 구조와 적절한 인덱싱이 더 효과적

- ENUM으로 성능 개선을 기대하는 것은 조기 최적화(premature optimization)

### 2-6. 재사용 불가

> ENUM은 다른 테이블에서 값을 공유할 수 없음

- 예: user.gender와 customer.gender 컬럼에서 동일한 ENUM이 필요할 경우
  - ENUM을 복사해서 넣어야 함 (DRY 원칙 위배)
  - 값 추가/삭제 시 모든 테이블을 일일이 수정해야 함
- 참조 테이블은 여러 테이블에서 동일 FK로 공유 가능

### 2-7. 입력 오류 발생 가능성

> ENUM은 내부적으로 인덱스를 사용하기 때문에 잘못된 값이 저장될 수 있음

- 예:

```sql
CREATE TABLE t (col ENUM('0', '1', '2'));
INSERT INTO t VALUES ('1'), (1);  -- 둘 다 OK
SELECT * FROM t;
-- 결과: '1', '0'
```

- 의도는 '1'이지만, 숫자 1은 ENUM의 1번 인덱스로 해석되어 '0'으로 저장
- 즉, 실수로도 잘못된 값이 silently 저장될 수 있음

### 2-8. 비표준 SQL 문법
- ENUM은 SQL 표준이 아니며, MySQL 독자 문법이다.
- PostgreSQL, SQLite 등은 ENUM을 지원하지 않거나 다른 방식으로 구현
- DBMS 변경 시 ENUM → 참조 테이블로 마이그레이션 필요
- 마이그레이션 비용 상승, ORM/라이브러리 호환성 문제

---

## 3. ENUM이 적합한 상황

- 절대 변경되지 않는 값: 카드 수트, 요일 등
- 연관 정보가 전혀 필요 없는 값: 단순 상태 값 등
- 값 개수가 3~20개 정도로 적고, 고정적일 때: 성별, 간단한 상태 구분 등