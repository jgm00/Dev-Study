# JPA vs MyBatis 외래 키 처리 방식 비교

## 목차
- [1. 기본 철학 차이](#1-기본-철학-차이)  
- [2. 외래 키 처리 방식 비교](#2-외래-키-처리-방식-비교)  
- [3. 장단점 비교](#3-장단점-비교)  
   - [JPA의 장점](#jpa의-장점)
   - [JPA의 단점](#jpa의-단점)
   - [MyBatis의 장점](#mybatis의-장점)
   - [MyBatis의 단점](#mybatis의-단점)
- [4. 실무 적용 팁](#4-실무-적용-팁)  
   - [JPA 사용 시](#jpa-사용-시)
   - [MyBatis 사용 시](#mybatis-사용-시)
- [5. 둘 중 어느 것을 써야 할까?](#5-둘-중-어느-것을-써야-할까)
   - [JPA가 더 적합한 상황](#jpa가-더-적합한-상황)
   - [MyBatis가 더 적합한 상황](#mybatis가-더-적합한-상황)

## 1. 기본 철학 차이

| 항목         | JPA (Java Persistence API)            | MyBatis                       |
| ------------ | -------------------------------------- | ----------------------------- |
| **패러다임**   | 객체 지향 프로그래밍 중심 (OOP)            | SQL 중심 프로그래밍               |
| **관계 표현**  | 객체 간 참조로 연관관계 설정                 | 외래 키 ID를 직접 저장             |
| **자동화 정도** | 관계 자동 매핑 및 관리 지원                 | 매핑과 로딩을 수동으로 처리         |
| **유연성**    | 도메인 중심 설계에 적합                    | SQL 최적화에 유리                |

---

## 2. 외래 키 처리 방식 비교

| 항목                    | JPA                                                              | MyBatis                                                   |
| ----------------------- | ---------------------------------------------------------------- | --------------------------------------------------------- |
| **외래 키 저장 방식**        | 관련 엔티티 객체 자체 저장<br>(ex: `private Customer customer`)     | 외래 키 ID를 명시적 필드로 저장<br>(ex: `private Long customerId`) |
| **관계 설정 방법**          | `@ManyToOne`, `@JoinColumn` 등 어노테이션 사용                          | `<resultMap>`, `<association>` 등 XML 수동 설정               |
| **데이터 저장 시 처리 방식** | `order.setCustomer(customer)` 와 같이 객체 저장                        | `order.setCustomerId(customerId)` 와 같이 ID 저장              |
| **조회 시 접근 방식**        | `order.getCustomer().getName()`<br>객체 그래프 탐색                     | `order.getCustomerId()` → 별도 SELECT 필요                    |
| **Lazy Loading 지원**   | 기본 지원 (`FetchType.LAZY`)                                     | 미지원 → 직접 구현 필요                                       |
| **양방향 관계 설정**       | `mappedBy` 등으로 간단하게 설정 가능                                     | 관계를 직접 수동 정리해야 함                                     |
| **Cascade 작업**        | `cascade = CascadeType.ALL` 등 설정 가능                           | 연쇄 저장/삭제는 직접 SQL 작성                                    |
| **쿼리 제어력**            | JPQL, Criteria API (제한적)                                     | SQL 직접 작성 (자유도 높음)                                     |
| **설정 복잡도**            | 어노테이션 조합 이해 필요                                           | 매핑 XML 반복 작업 많음                                        |
| **실무 적합도**            | 도메인 중심 서비스에 적합                                           | 리포트, 배치, 성능 최적화에 적합                                    |

---

## 3. 장단점 비교

### JPA의 장점

- 객체 지향적인 코드 작성 가능  
- 지연 로딩, 즉시 로딩 전략 선택 가능  
- 캐싱 기능 기본 제공  
- 연관 관계 변경 시 쿼리 수정 최소화  

### JPA의 단점

- 복잡한 쿼리 처리에 제한적  
- 자동 생성된 SQL의 성능 이슈 가능성  
- N+1 문제 등 성능 함정 존재  

### MyBatis의 장점

- SQL에 대한 완전한 제어 가능  
- 성능 최적화 용이  
- 복잡한 쿼리 작성 자유도 높음  
- 레거시 시스템과의 통합 용이  

### MyBatis의 단점

- 반복적인 CRUD 코드 작성 필요  
- 객체 관계 매핑을 수동으로 처리  
- 스키마 변경 시 SQL 수정 작업 발생  
- 엔티티 간 관계 표현이 명시적이지 않음  

---

## 4. 실무 적용 팁

### JPA 사용 시  
  - `@EntityGraph`, QueryDSL 등을 통해 N+1 문제를 완화  
  - `FetchType.LAZY`를 기본값으로 두되 필요한 경우에만 EAGER로  
  - `@Transactional`의 올바른 범위 설정 중요  
  - 테스트 환경과 운영 환경의 DB 특성을 반영한 튜닝 필요  

### MyBatis 사용 시  
  - SQL 관리 체계화 (Mapper 분리, 네이밍 룰 통일 등)  
  - 동적 SQL보다 명시적 SQL 우선 고려  
  - 재사용 가능한 SQL 구성요소(template) 활용  
  - MyBatis Generator 등 코드 생성 도구 적극 활용  

---

## 5. 둘 중 어느 것을 써야 할까?

### JPA가 더 적합한 상황

- 도메인 객체 간 관계 모델링이 중요한 경우  
- 비즈니스 로직이 복잡하고 객체 탐색이 많은 경우  
- DDD, CQRS 등 고수준 설계를 적용하는 경우  
- 빠른 개발 속도가 필요한 프로젝트  

### MyBatis가 더 적합한 상황

- SQL 튜닝과 제어가 필요한 상황  
- 트래픽이 많고 성능이 중요한 시스템  
- 복잡한 조인 쿼리를 직접 다뤄야 하는 상황  
- 명확하고 예측 가능한 SQL이 요구되는 프로젝트  
